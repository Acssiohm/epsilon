/* Normally, Flex will call yywrap when reaching an end-of-file. We don't want
 * to deal with files anyway, so let's just disable this. */
%option noyywrap

/* We're using the bison-bridge option because the bison parser is reentrant,
 * as specified by the "pure-parser" option. Using the bison-bridge option
 * prevents Flex from using global variables such as yylval. Instead, those
 * become local pointers that are passed by Bison to Flex.
 * In practice, when using bison-bridge, you shall simply use yylval as a
 * pointer.
 */
%option bison-bridge

/* Normally, on each new input file the scanner calls isatty() in an attempt to
 * determine whether the scanner's input source is interactive and thus should
 * be read a character at a time.
 * We obviously do *not* provide isatty(), and we know we're never going to use
 * an interactive input source. */
%option never-interactive

%{
/* Flex generate a lexer, a function that outputs tokens.
 * Those tokens (and the optional value that they can be attached) are defined
 * in the Bison grammar. To use those token definitions, we need to include the
 * header generated by Bison.
 * Also, since some tokens can have an "Expression *" value attached, we'll
 * need "Expression" to be defined before including that header.
 * We could use the '%code requires{}' directive to make sure that Expression is
 * well defined in the parser header, but this directive only comes in bison 3,
 * which is not installed by default on MacOS, we thus made the choice to prefer
 * compatibility with MacOS's default version (2.3) instead of using the code
 * requires feature. */
#include <cmath>

/* YYSTYPE has to be defined in expression_parser.y, expression.cpp and here
 * because the genereated code is included in expression_parser.cpp, not .hpp
 * so we cannot use expression_parser.hpp here. We use an additional header
 * which only define YYSTYPE. This should be discarded with Bison 3. */
#include "expression_lexer_parser.h"

#include "expression_parser.hpp"
using namespace Poincare;

/* Flex has provision for reading files. We'll never use this, so we're defining
 * YY_INPUT which effectively disables taking input from a file. */
#define YY_INPUT

/* Flex can print to stdout what token it matches by calling the ECHO function.
 * We don't want that feature : we don't even have printf ! */
#define ECHO

/* This defines the size of the flex buffer size.
 * By default this buffer is of 16k, but we don't have the luxury to use so much
 * memory on a microcontroller.
 * The choice of 256 Bytes is the size of the input buffer given to flex in the
 * current implementation (the app takes a maximum of 256).
 */
#undef YY_BUF_SIZE
#define YY_BUF_SIZE 256

#define fprintf(...) ((void)0)
#define exit(...) abort()

%}

%%

 /* If two patterns can match the same input, flex resolves the ambiguity:
  * - By matching the longest possible string
  * - In a tie, by using the pattern that appears first
  *
  * Also note that yytext is guaranteed to be null-terminated when the token is
  * being built, (i.e. when flex calls our code snippet), but this is achieved
  * by flex temporarily swapping the last character. Afterwards the pointer is
  * still valid but the string isn't null-terminated anymore.
  */
  /* We designed our own extended-ASCII to include requiered symbols in less
   * than 255 glyphs. The file ion/include/ion/charset.h lists all added
   * non-ASCII symbols with their char associated. For example, the char \x89
   * refered to Pi symbols. This artefact leads to the following lexer rules
   * starting with \x. */

(([0-9]*[.]?[0-9]+)|([0-9]+[.]?[0-9]*))(\x8d\-?[0-9]+)? { yylval->expression = Poincare::Number::ParseDigits(yytext, yyleng); return DIGITS; }
[A-Za-z] { yylval->expression = Poincare::Symbol(yytext[0]); return SYMBOL; }
M[0-9] { yylval->expression = Poincare::Symbol(Symbol::matrixSymbol(yytext[1])); return SYMBOL; }
u\(n\) { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::un); return SYMBOL; }
u\(n\+1\) { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::un1); return SYMBOL; }
v\(n\) { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::vn); return SYMBOL; }
v\(n\+1\) { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::vn1); return SYMBOL; }
u\_\{n\} { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::un); return SYMBOL; }
u\_\{n\+1\} { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::un1); return SYMBOL; }
v\_\{n\} { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::vn); return SYMBOL; }
v\_\{n\+1\} { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::vn1); return SYMBOL; }
V1 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::V1); return SYMBOL; }
N1 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::N1); return SYMBOL; }
V2 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::V2); return SYMBOL; }
N2 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::N2); return SYMBOL; }
V3 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::V3); return SYMBOL; }
N3 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::N3); return SYMBOL; }
X1 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::X1); return SYMBOL; }
Y1 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::Y1); return SYMBOL; }
X2 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::X2); return SYMBOL; }
Y2 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::Y2); return SYMBOL; }
X3 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::X3); return SYMBOL; }
Y3 { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::Y3); return SYMBOL; }
acos { yylval->expression = ArcCosine(); return FUNCTION; }
acosh { yylval->expression = HyperbolicArcCosine(); return FUNCTION; }
abs { yylval->expression = AbsoluteValue(); return FUNCTION; }
ans { yylval->expression = Poincare::Symbol(Symbol::SpecialSymbols::Ans); return SYMBOL; }
arg { yylval->expression = ComplexArgument(); return FUNCTION; }
asin { yylval->expression = ArcSine(); return FUNCTION; }
asinh { yylval->expression = HyperbolicArcSine(); return FUNCTION; }
atan { yylval->expression = ArcTangent(); return FUNCTION; }
atanh { yylval->expression = HyperbolicArcTangent(); return FUNCTION; }
binomial { yylval->expression = BinomialCoefficient(); return FUNCTION; }
ceil { yylval->expression = Ceiling(); return FUNCTION; }
confidence { yylval->expression = ConfidenceInterval(); return FUNCTION; }
diff { yylval->expression = Derivative(); return FUNCTION; }
dim { yylval->expression = MatrixDimension(); return FUNCTION; }
conj { yylval->expression = Conjugate(); return FUNCTION; }
det { yylval->expression = Determinant(); return FUNCTION; }
cos { yylval->expression = Cosine(); return FUNCTION; }
cosh { yylval->expression = HyperbolicCosine(); return FUNCTION; }
factor { yylval->expression = Factor(); return FUNCTION; }
floor { yylval->expression = Floor(); return FUNCTION; }
frac { yylval->expression = FracPart(); return FUNCTION; }
gcd { yylval->expression = GreatCommonDivisor(); return FUNCTION; }
im { yylval->expression = ImaginaryPart(); return FUNCTION; }
int { yylval->expression = Integral(); return FUNCTION; }
inverse { yylval->expression = MatrixInverse(); return FUNCTION; }
lcm { yylval->expression = LeastCommonMultiple(); return FUNCTION; }
ln { yylval->expression = NaperianLogarithm(); return FUNCTION; }
log { return LOGFUNCTION; }
permute { yylval->expression = PermuteCoefficient(); return FUNCTION; }
prediction95 { yylval->expression = PredictionInterval(); return FUNCTION; }
prediction { yylval->expression = SimplePredictionInterval(); return FUNCTION; }
product { yylval->expression = Product(); return FUNCTION; }
quo { yylval->expression = DivisionQuotient(); return FUNCTION; }
random { yylval->expression = Random(); return FUNCTION; }
randint { yylval->expression = Randint(); return FUNCTION; }
re { yylval->expression = RealPart(); return FUNCTION; }
rem { yylval->expression = DivisionRemainder(); return FUNCTION; }
root { yylval->expression = NthRoot(); return FUNCTION; }
round { yylval->expression = Round(); return FUNCTION; }
sin { yylval->expression = Sine(); return FUNCTION; }
sinh { yylval->expression = HyperbolicSine(); return FUNCTION; }
sum { yylval->expression = Sum(); return FUNCTION; }
tan { yylval->expression = Tangent(); return FUNCTION; }
tanh { yylval->expression = HyperbolicTangent(); return FUNCTION; }
trace { yylval->expression = MatrixTrace(); return FUNCTION; }
transpose { yylval->expression = MatrixTranspose(); return FUNCTION; }
undef { yylval->expression = Undefined(); return UNDEFINED; }
inf { yylval->expression = Undefined(); return UNDEFINED; }
\x8a { yylval->expression = Poincare::Symbol(yytext[0]); return SYMBOL; }
\x8c { yylval->expression = Poincare::Symbol(yytext[0]); return SYMBOL; }
\x8f { yylval->expression = Poincare::Symbol(yytext[0]); return SYMBOL; }
\x90 { return STO; }
\x91 { yylval->expression = SquareRoot(); return FUNCTION; }
= { return EQUAL; }
\+ { return PLUS; }
\- { return MINUS; }
\x94 { return MULTIPLY; }
\x95 { return MULTIPLY; }
\* { return MULTIPLY; }
\/ { return DIVIDE; }
\^ { return POW; }
\! { return BANG; }
\( { return LEFT_PARENTHESIS; }
\) { return RIGHT_PARENTHESIS; }
\{ { return LEFT_BRACE; }
\} { return RIGHT_BRACE; }
\[ { return LEFT_BRACKET; }
\] { return RIGHT_BRACKET; }
\, { return COMMA; }
\_ { return UNDERSCORE; }
\x97 { yylval->expression = EmptyExpression(); return EMPTY; }
[ ]+ /* Ignore whitespaces */
. { return UNDEFINED_SYMBOL; }

%%
